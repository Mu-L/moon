#  简介
Moon是一个轻量级的游戏服务器框架，框架本身没有提供游戏相关的业务逻辑，你需要根据自己的实际需求来设计自己的服务器。

框架处理流程图

![image](https://github.com/sniper00/MoonNetLua/raw/master/image/01.png)

## 框架

游戏服务器中我们经常需要开发一些特殊模块（如网关，登陆，数据库模块），和一些通用的模块（如副本模块）。这些模块经常需要互相通信来给玩家提供服务。传统的多进程设计，通常会采用socket用于模块间通信，这样就需要维护多个网络连接，处理网络的各种异常情况，比较麻烦。Moon中以服务（service）来表示某个模块，服务可以添加一些组件来使服务具有一些功能（暂时提供了tcp网络组件,为服务提供网络通信功能）。你可以用服务来处理游戏逻辑，或者存储游戏状态。

Moon采用的是多线程来处理各个服务，一条线程可以含有1到N个服务。对于特殊的服务，如网关服务，负责把客户端发来的消息转发给其他服务，我们希望它能高效的转发消息，而不受其它影响，可以把它绑定到单独线程来运行;
Mysql数据库服务，由于官方提供的客户端是阻塞模式的api,我们希望阻塞操作不要影响其它服务的运行。这些情况下我们都可以让服务单独占用一条线程，提供异步数据库服务。对于通用的服务，如游戏场景服务，卡牌游戏的房间等，这些服务共同的特点就是会开启几百甚至几千个，它们之间的优先级是平等的，这样的服务可以被轮询地添加到剩余的工作线程中。

一般情况下，所有服务都在一个进程中，服务间的通信只是传递一个数据指针，比进程间通过IO通信高效的多。一个进程中的所有服务是同生共死的，服务间通信不必时刻关心对方是否还活着，通讯数据能否正确到达等问题。服务一般采用lua编写，这就提供了运行沙盒，防止某个服务crash而影响其他服务。对于性能要求较高的场合，可以采用C++编写服务，但这样就需要对C++有较高的理解，因为C++编写的服务如果crash会影响整个进程。由于框架本身是跨平台的，建议也是用跨平台的C++代码来编写服务。也可以先用lua编写服务原型，验证可行性后，在翻译成C++代码。

## 网络 
Moon是以服务来处理具体业务的，默认情况下服务是不具有网络功能的，我们可以给服务添加网络模块。网络模块暂时只具有监听端口，建立tcp连接，收发tcp数据包功能。网络数据会传递给当前所在的服务进行处理，通过消息类型来区分网络消息和服务间通信的消息。对于收到的网络数据，消息的发送者就是网络连接的sessionid, 逻辑层可以通过这个id和客户端进行通信。

现在支持三种模式：
- 2字节大端来表示数据长度的协议，这个是默认模式。这个数据长度不包含表示长度的2字节数据
- websocket ,现在只支持服务端
- 自定义解析，框架自带的redis客户端就是用的这种模式

客户端端想和服务器通信，只需要遵循这个分包协议，可以编写C/C++,C# ,lua,python等客户端。数据内容的格式可以自定义，如google protocol buffers 或者 json,或者自定义的协议。

## 消息 
每条消息有：发送者服务id、接收者服务id、消息头、消息数据、responseid、消息类型 组成。

消息的数据分为 消息头和数据，这样做的原因是为某些应用场景减少数据拷贝进行优化，例如 场景内某个玩家释放了技能，需要对周围玩家广播，对于周围玩家来说这是同一份数据，但对服务器来说数据是：接收者id+玩家释放技能数据，通过网关服务广播给多个客户端，由于接收者id是不同的客户端，这样就需要对数据重新进行组装，产生额外的数据拷贝。为了避免这种情况，我们可以把接收者id储存在消息头中，把技能数据存在消息数据中，这样网关服务只用检查消息头的接收者id,就可以把同一份数据发送给多个玩家。消息数据部分采用了引用计数的智能指针存储，使用完后会自动释放。

type用来区分不同类型的消息，主要有服务数据，网络数据，框架内部调试数据。

responseid 是应用于请求回应模式，主要用于不同服务间通信，有时我们发送一条消息，并希望得到消息的处理结果，发送消息时附带一个responseid,并绑定一个回掉函数，对方收到后把responseid 发送回来，触发回掉函数。

## 协程
不同服务间的异步调用提供了协程封装。带有responseid的消息调用都可以转换为协程。




